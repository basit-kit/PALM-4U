calc_radiation.f90:           ONLY:  nxl, nxr, nyn, nys, nzb, nzb_s_inner, nzt
calc_radiation.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
calc_radiation.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
calc_radiation.f90:           ONLY:  nzb, nzb_s_inner, nzt
calc_radiation.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
calc_radiation.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
Binary file palm_sources.tar matches
palm.f90:               nzb_diff_u, nzb_diff_v, nzb_s_inner, nzb_s_outer, nzb_u_inner,  &
palm.f90:    !$acc       copyin( nzb_diff_v, nzb_s_inner, nzb_s_outer, nzb_u_inner )    &
Binary file .land_surface_model_mod.f90.swp matches
surface_layer_fluxes_mod.f90:        ONLY:  nxl, nxlg, nxr, nxrg, nys, nysg, nyn, nyng, nzb_s_inner,        &
surface_layer_fluxes_mod.f90:          k    = MINVAL(nzb_s_inner)
surface_layer_fluxes_mod.f90:       !$acc kernels loop present( nzb_s_inner, u, uv_total, v ) private( j, k )
surface_layer_fluxes_mod.f90:             k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:          !$acc data present( nzb_s_inner, pt, q, qsws, rib, shf, uv_total, vpt, zu, zw )
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:          !$acc kernels loop present( nzb_s_inner, ol, pt, pt1, q, ql, qs, qv1, ts, us, vpt, zu, zw ) private( j, k, z_mo )
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:       !$acc kernels loop present( nzb_s_inner, ol, us, uv_total, zu, zw, z0 ) private( j, k, z_mo )
surface_layer_fluxes_mod.f90:             k   = nzb_s_inner(j,i)+1
surface_layer_fluxes_mod.f90:       !$acc kernels loop present( nzb_s_inner, pt, pt1, pt_d_t, q, ql, qv1 ) private( j, k )
surface_layer_fluxes_mod.f90:             k   = nzb_s_inner(j,i)+1
surface_layer_fluxes_mod.f90:       !$acc data present( e, nrsws, nzb_u_inner, nzb_v_inner, nzb_s_inner, pt )  &
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:                   k = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:          !$acc kernels loop present( nzb_s_inner, ol, pt, pt1, ts, zu, zw, z0h ) private( j, k, z_mo )
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:                   k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:                      k = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:             !$acc kernels loop independent present( nzb_s_inner, ol, pt, q, qs, qv1, zu, zw, z0q ) private( e_s, j, k, z_mo )
surface_layer_fluxes_mod.f90:                   k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:          !$acc kernels loop independent present( nr, nrs, nzb_s_inner, ol, qr, qrs, zu, zw, z0q ) private( j, k, z_mo )
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:                k   = nzb_s_inner(j,i)
surface_layer_fluxes_mod.f90:          !$acc kernels loop independent present( e, nzb_s_inner, us )
surface_layer_fluxes_mod.f90:                k = nzb_s_inner(j,i)
pmc_interface_mod.f90:               nysv, nz, nzb, nzb_s_inner, nzb_u_inner, nzb_u_outer,            &
pmc_interface_mod.f90:             DO  k = nzb_s_inner(j,i) + 1, nzt
pmc_interface_mod.f90:                height = zu(k) - zu(nzb_s_inner(j,i))
pmc_interface_mod.f90:             tkefactor_l(nzb_s_inner(j,i),j) = c_tkef * fw0
pmc_interface_mod.f90:             DO  k = nzb_s_inner(j,i) + 1, nzt
pmc_interface_mod.f90:                height = zu(k) - zu(nzb_s_inner(j,i))
pmc_interface_mod.f90:             tkefactor_r(nzb_s_inner(j,i),j) = c_tkef * fw0
pmc_interface_mod.f90:             DO  k = nzb_s_inner(j,i) + 1, nzt
pmc_interface_mod.f90:                height = zu(k) - zu(nzb_s_inner(j,i))
pmc_interface_mod.f90:             tkefactor_s(nzb_s_inner(j,i),i) = c_tkef * fw0
pmc_interface_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
pmc_interface_mod.f90:                height = zu(k) - zu(nzb_s_inner(j,i))
pmc_interface_mod.f90:             tkefactor_n(nzb_s_inner(j,i),i) = c_tkef * fw0
pmc_interface_mod.f90:             height = zu(k) - zu(nzb_s_inner(j,i))
pmc_interface_mod.f90:                                   r2yo, r1zo, r2zo, nzb_s_inner, 'e' )
pmc_interface_mod.f90:                                      r1yo, r2yo, r1zo, r2zo, nzb_s_inner, 's' )
pmc_interface_mod.f90:                                      r2yo, r1zo, r2zo, nzb_s_inner, 's' )
pmc_interface_mod.f90:                                      r2yo, r1zo, r2zo, nzb_s_inner, 's' )
pmc_interface_mod.f90:                e(nzb:nzb_s_inner(j,i),j,i)   = 0.0_wp
pmc_interface_mod.f90:                e_p(nzb:nzb_s_inner(j,i),j,i) = 0.0_wp
pmc_interface_mod.f90:                   e(nzb:nzb_s_inner(j,i),j,i)  = 0.0_wp
pmc_interface_mod.f90:!                   pt(nzb:nzb_s_inner(j,i),j,i) = 0.0_wp
pmc_interface_mod.f90:!                      q(nzb:nzb_s_inner(j,i),j,i) = 0.0_wp
pmc_interface_mod.f90:                                       r1yo, r2yo, r1zo, r2zo, nzb_s_inner,     &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                CALL pmci_extrap_ifoutflow_lr( e, nzb_s_inner, 'l', 'e' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_lr( pt,nzb_s_inner, 'l', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_lr( q, nzb_s_inner, 'l', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_lr( s, nzb_s_inner, 'l', 's' )
pmc_interface_mod.f90:                                       r1yo,r2yo, r1zo, r2zo, nzb_s_inner,      &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                CALL pmci_extrap_ifoutflow_lr( e, nzb_s_inner, 'r', 'e' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_lr( pt,nzb_s_inner, 'r', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_lr( q, nzb_s_inner, 'r', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_lr( s, nzb_s_inner, 'r', 's' )
pmc_interface_mod.f90:                                       r1yo, r2yo, r1zo, r2zo, nzb_s_inner,     &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo,r2yo, r1zo, r2zo, nzb_s_inner,   &
pmc_interface_mod.f90:                                          r1yo,r2yo, r1zo, r2zo, nzb_s_inner,   &
pmc_interface_mod.f90:                CALL pmci_extrap_ifoutflow_sn( e, nzb_s_inner, 's', 'e' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_sn( pt,nzb_s_inner, 's', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_sn( q, nzb_s_inner, 's', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_sn( s, nzb_s_inner, 's', 's' )
pmc_interface_mod.f90:                                       r1yo, r2yo, r1zo, r2zo, nzb_s_inner,     &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                                          r1yo, r2yo, r1zo, r2zo, nzb_s_inner,  &
pmc_interface_mod.f90:                CALL pmci_extrap_ifoutflow_sn( e, nzb_s_inner, 'n', 'e' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_sn( pt,nzb_s_inner, 'n', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_sn( q, nzb_s_inner, 'n', 's' )
pmc_interface_mod.f90:                   CALL pmci_extrap_ifoutflow_sn( s, nzb_s_inner, 'n', 's' )
advec_s_pw.f90:           ONLY:  nxl, nxlg, nxr, nxrg, nyn, nyng, nys, nysg, nzb, nzb_s_inner,&
advec_s_pw.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
advec_s_pw.f90:           ONLY:  nxlg, nxrg, nyng, nysg, nzb, nzb_s_inner, nzt
advec_s_pw.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
task1_kchem_driver.f90:   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn
task1_kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc           
task1_kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp
task1_kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo
task1_kchem_driver.f90:      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context
task1_kchem_driver.f90:         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo
task1_kchem_driver.f90:         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo
diffusion_e.f90:           ONLY:  nxl, nxlg, nxr, nxrg, nyn, nyng, nys, nysg, nzb, nzb_s_inner,&
diffusion_e.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                                     ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:                                     ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                                     ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:                                     ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                diss(nzb_s_inner(j,i),j,i) = diss(nzb_s_inner(j,i)+1,j,i)
diffusion_e.f90:                  nzb, nzb_s_inner, nzt
diffusion_e.f90:          !$acc         present( nzb_s_inner, tend, var, zu, zw )
diffusion_e.f90:                   IF ( k > nzb_s_inner(j,i) )  THEN
diffusion_e.f90:                                   ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:                                   ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:          !$acc         present( nzb_s_inner, tend, var, zu, zw )
diffusion_e.f90:                   IF ( k > nzb_s_inner(j,i) )  THEN
diffusion_e.f90:                                   ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:                                   ( zu(k) - zw(nzb_s_inner(j,i)) ), &
diffusion_e.f90:          !$acc kernels present( diss, nzb_s_inner )
diffusion_e.f90:                diss(nzb_s_inner(j,i),j,i) = diss(nzb_s_inner(j,i)+1,j,i)
diffusion_e.f90:           ONLY:  nxlg, nxrg, nyng, nysg, nzb, nzb_s_inner, nzt
diffusion_e.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:                          ( zu(k) - zw(nzb_s_inner(j,i)) ), l_grid(k), &
diffusion_e.f90:                          ( zu(k) - zw(nzb_s_inner(j,i)) ), l_grid(k) )
diffusion_e.f90:          DO  k = nzb_s_inner(j,i)+1, nzt
diffusion_e.f90:          diss(nzb_s_inner(j,i),j,i) = diss(nzb_s_inner(j,i)+1,j,i)
Binary file .init_3d_model.f90.swp matches
urban_surface_mod.f90:               nysg, nzb_s_inner, nzb_s_outer, nzb, nzt, nbgp
urban_surface_mod.f90:        nzubl = minval(nzb_s_inner(nys:nyn,nxl:nxr))
urban_surface_mod.f90:        nzutl = maxval(nzb_s_inner(nys:nyn,nxl:nxr))
urban_surface_mod.f90:                            pct(j,i) = k + nzb_s_inner(j,i)
urban_surface_mod.f90:                    nsurfl = nsurfl + max(0, nzb_s_inner(jr,ir)-nzb_s_inner(j,i))
urban_surface_mod.f90:                        k = nzut - max(nzb_s_inner(j,i), nzb_s_inner(j-jdir(ids),i-idir(ids)))
urban_surface_mod.f90:                    DO k = nzb_s_inner(j,i)+1, pct(j,i)
urban_surface_mod.f90:                k = nzb_s_inner(j,i)+1
urban_surface_mod.f90:                    DO k = nzb_s_inner(j,i)+1, nzb_s_inner(jr,ir)
urban_surface_mod.f90:                        DO k = max(nzb_s_inner(j,i),nzb_s_inner(j-jdir(ids),i-idir(ids)))+1, nzut
urban_surface_mod.f90:        nzterrl = nzb_s_inner(nys:nyn,nxl:nxr)
urban_surface_mod.f90:        nzterr = RESHAPE( nzb_s_inner(nys:nyn,nxl:nxr), (/(nx+1)*(ny+1)/) )
urban_surface_mod.f90:                    k = nzb_s_inner(j, i)
urban_surface_mod.f90:                     DO k = nzb_s_inner(j,i), nzut
urban_surface_mod.f90:                         temp_pf(k,j,i) = lad_s(k-nzb_s_inner(j,i),j,i)
urban_surface_mod.f90:                     DO k = nzb_s_inner(j,i), nzut
urban_surface_mod.f90:                         temp_pf(k,j,i) = pc_heating_rate(k-nzb_s_inner(j,i),j,i)
urban_surface_mod.f90:                kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
urban_surface_mod.f90:!--         for horizontal surfaces is pt(nzb_s_inner(j,i),j,i) = pt_surf.
urban_surface_mod.f90:               pt(nzb_s_inner(j,i),j,i) = t_surf_p(l) / exn(k)
urban_surface_mod.f90:!--                     TODO the increase of pt in box i,j,nzb_s_inner(j,i)+1 in time dt_3d 
urban_surface_mod.f90:!--                     k = nzb_s_inner(j,i)+1
urban_surface_mod.f90:               IF ( k >=  nzb_s_inner(j,i)+1  .AND.  k <=  nzb_s_outer(j,i) ) THEN
pres.f90:! using the rflags_s_inner multiply flag instead of the nzb_s_inner loop index
pres.f90:               ny, nys, nysg, nys_mg, nyn, nyng, nyn_mg, nzb, nzb_s_inner,     &
pres.f90:          DO  k = nzb_s_inner(j,i)+1, nzt
pres.f90:          DO  k = nzb_s_inner(j,i)+1, nzt
pres.f90:          !$acc kernels present( nzb_s_inner, tend )
pres.f90:                tend(nzb_s_inner(j,i),j,i) = tend(nzb_s_inner(j,i)+1,j,i)
pres.f90:                tend(nzb_s_inner(j,i),j,i) = 0.0_wp
pres.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
newfile.f90:!> @file kchem_driver.f90!------------------------------------------------------------------------------!! This file is part of PALM.!! PALM is free software: you can redistribute it and/or modify it under the! terms of the GNU General Public License as published by the Free Software! Foundation, either version 3 of the License, or (at your option) any later! version.!! PALM is distributed in the hope that it will be useful, but WITHOUT ANY! WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR! A PARTICULAR PURPOSE.  See the GNU General Public License for more details.!! You should have received a copy of the GNU General Public License along with! PALM. If not, see <http://www.gnu.org/licenses/>.!! Copyright 1997-2016 Leibniz Universitaet Hannover!------------------------------------------------------------------------------!!! Current revisions:! -----------------! kk: Intial version (Klaus Ketelsen)! bK: Changed initial values of chem_species! RFo: Added tmp_fact! FKa: Some formatting, todos added below, "_wp" added to REAL quantities' values,!      the "if(var(1:3) == 'kc_')" is now included in check_parameters (as done!      for "usm_" quantities!! Former revisions:! -----------------!! Description:! ------------!> Interface PALM <-> kpp chemistry!>!> @todo Format this module according to PALM coding standard (see e.g. module!>       template under http://palm.muk.uni-hannover.de/mosaik/downloads/8 or!>       D3_coding_standard.pdf under https://palm.muk.uni-hannover.de/trac/downloads/16)!> @todo Rename ssws, sswst to csws, cswst to avoid confusion with ssws/sswst !>       used together with passive scalar s!> @todo Use same run index for all loops over NSPEC, e.g. nsp = 1, NSPEC!>       (and: NSPEC-->nspec, i.e. no capital letters in variable names !>       [see formatting rules])!> @todo "#ifdef KPP_CHEM" --> "#if defined( __chem)" (see other examples !>       in PALM)               #if defined( __parallel )!> @todo „write(6...“ printing should eventually be handled in a separate !>       subroutine „kchem_header“ (see e.g. how it is done in routine !>       lsm_header in land_surface_model_mod.f90), which prints this !>       information to a MONITORING file named <jobname>_header (in this file, !>       all PALM setup information are included)!> @todo Not all routines have meaningful names yet, e.g. "kchem_integrate" only!>       refers to chemical reactions part, but the name itself could also refer!>       to the other part of the chemistry integration (advection/diffusion)!>       --> Please clarify!> @todo Rename flag „use_kpp_chemistry“ to „chemistry“ (see e.g. flag !>       „plant_canopy“ used for the plant canopy model!> @todo Please enter all of your TODOs here in this list!> @todo Every subroutine needs a "Description" header !>       (as e.g. in urban_surface_mod.f90)!> @todo Clear circular dependencies between check_parameters, kchem_initialize,!>       and kchem_check_data_output!------------------------------------------------------------------------------!ODULE kchem_driver   USE kinds,              ONLY: wp, iwp   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn   USE pegrid,             ONLY: myid, threads_per_task   USE control_parameters, ONLY: dt_3d, ws_scheme_sca  !ws_sch... added by bK   USE arrays_3d,          ONLY: pt   USE kchem_kpp,          ONLY: NSPEC, SPC_NAMES, NKPPCTRL, NMAXFIXSTEPS, t_steps, FILL_TEMP, kpp_integrate,     &                                 ATOL,RTOL   USE cpulog,             ONLY: cpu_log, log_point_s   IMPLICIT   none   PRIVATE   SAVE!- Define chemical variables   TYPE   species_def      CHARACTER(LEN=8)                                   :: name      CHARACTER(LEN=16)                                  :: unit      REAL(kind=wp),POINTER,DIMENSION(:,:,:)             :: conc      REAL(kind=wp),POINTER,DIMENSION(:,:,:)             :: conc_p      REAL(kind=wp),POINTER,DIMENSION(:,:,:)             :: tconc_m      REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:)           :: ssws, sswst      REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:)           :: flux_s, diss_s      REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:,:)         :: flux_l, diss_l   END TYPE species_def   PUBLIC  species_def   logical, PUBLIC                                               :: use_kpp_chemistry = .FALSE.   TYPE(species_def),ALLOCATABLE,DIMENSION(:),TARGET, PUBLIC     :: chem_species   REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:,:,:),TARGET   :: spec_conc_1,spec_conc_2,spec_conc_3   INTEGER,DIMENSION(NKPPCTRL)                           :: icntrl                            ! Fine tuning kpp   REAL(kind=wp),DIMENSION(NKPPCTRL)                     :: rcntrl                            ! Fine tuning kpp   PUBLIC NSPEC!- Interface section   INTERFACE kchem_boundary_conds      MODULE PROCEDURE kchem_boundary_conds   END INTERFACE kchem_boundary_conds   INTERFACE kchem_initialize      MODULE PROCEDURE kchem_initialize   END INTERFACE kchem_initialize   INTERFACE kchem_parin      MODULE PROCEDURE kchem_parin   END INTERFACE kchem_parin   INTERFACE kchem_integrate      MODULE PROCEDURE kchem_integrate_ij   END INTERFACE kchem_integrate   INTERFACE kchem_swap_timelevel      MODULE PROCEDURE kchem_swap_timelevel   END INTERFACE kchem_swap_timelevel   INTERFACE kchem_define_netcdf_grid      MODULE PROCEDURE kchem_define_netcdf_grid   END INTERFACE kchem_define_netcdf_grid   INTERFACE kchem_data_output_3d      MODULE PROCEDURE kchem_data_output_3d   END INTERFACE kchem_data_output_3d   INTERFACE kchem_check_data_output      MODULE PROCEDURE kchem_check_data_output   END INTERFACE kchem_check_data_output   PUBLIC kchem_boundary_conds, kchem_check_data_output, kchem_data_output_3d, &          kchem_define_netcdf_grid, kchem_initialize, kchem_integrate,         &          kchem_parin, kchem_swap_timelevel             CONTAINS !------------------------------------------------------------------------------!! Description:! ------------!> Initialize and set all boundary conditions for chemical species concentration!------------------------------------------------------------------------------! SUBROUTINE kchem_boundary_conds( mode )                                        !Please note alphabetical order of listings, and also all other formatting                                                                                !and continue in that exact way.    USE control_parameters,                                                    & !you might also have to add some other quantities here, since        ONLY: outflow_l, outflow_n, outflow_r, outflow_s            USE indices,                                                               & !I didn't check for all that might be necessary to add to ONLY list        ONLY: nxlg, nxrg, nyng, nysg      IMPLICIT NONE        CHARACTER (len=*), INTENT(IN) :: mode    SELECT CASE ( TRIM( mode ) )       CASE ( 'init' )!         This part below is from check_parameters.f90's SUBROUTINE set_bc_scalars!         I already adjusted this part to work for chem species (see notes under CASE('set_bc_bottomtop'))!!--       Set Integer flags and check for possible erroneous settings for !--       bottom boundary condition  (the integer flags are then used in CASE('set_bc_bottomtop'))          IF ( bc_c_b == 'dirichlet' )  THEN             ibc_c_b = 0          ELSEIF ( bc_c_b == 'neumann' )  THEN             ibc_c_b = 1          ELSE             message_string = 'unknown boundary condition: bc_c_b ="' // TRIM( bc_c_b ) // '"'             CALL message( 'kchem_boundary_conds', 'CHEM001', 1, 2, 0, 6, 0 )     !checks in kchem_driver have special error numbers --> "CHEM###",          ENDIF                                                                   !so that we don't mix them up with PALM error numbers "PA0###"!!--       Set Integer flags and check for possible erroneous settings for top!--       boundary condition          IF ( bc_c_t == 'dirichlet' )  THEN             ibc_c_t = 0          ELSEIF ( bc_c_t == 'neumann' )  THEN             ibc_c_t = 1          ELSEIF ( bc_c_t == 'initial_gradient' )  THEN             ibc_c_t = 2          ELSEIF ( bc_c_t == 'nested' )  THEN             ibc_c_t = 3          ELSE             message_string = 'unknown boundary condition: bc_c_t ="' // TRIM( bc_c_t ) // '"'             CALL message( 'check_parameters', 'CHEM002', 1, 2, 0, 6, 0 )          ENDIF!!--       We might later on need some parameter checkings as in check_parameters.f90's SUBROUTINE check_bc_scalars!--       (these should be put under a new SUBROUTINE kchem_check_parameters, see e.g. urban_surface_mod.f90 also has SUBROUTINE usm_check_parameters)               CASE ( 'set_bc_bottomtop' ) !!--       Surface conditions for chemical species     !!!!this is the code for passive_scalar (copied from boundary_conds.f90)                                                       !!!!---> modify this to work for chemical species!!!          IF ( ibc_s_b == 0 ) THEN                    !use "ibc_c_b" for chem species. you have to declare it in kchem_driver's global decleration part.                                                      !and make it PUBLICly available. same holds for ibc_c_t, bc_c_b/bc_c_t.                                                      !don't confuse the integer flag "ibc_c_b" with the &kpp_chem parameter "bc_c_b" which needs to                                                      !be defined as a parameter in kchem_parin. "bc_c_b" can take the same values as "bc_s_b" (see PALM                                                      !documentation)             DO  i = nxlg, nxrg                                       DO  j = nysg, nyng                                               s_p(nzb_s_inner(j,i),j,i) = s(nzb_s_inner(j,i),j,i)                ENDDO             ENDDO          ELSE             DO  i = nxlg, nxrg                DO  j = nysg, nyng                   s_p(nzb_s_inner(j,i),j,i) = s_p(nzb_s_inner(j,i)+1,j,i)                ENDDO             ENDDO          ENDIF!!--       Top boundary conditions for chemical species          IF ( ibc_s_t == 0 )  THEN                    !use "ibc_c_t" for chem species. you have to declare it in kchem_driver global decleration part             s_p(nzt+1,:,:) = s(nzt+1,:,:)             !(see notes for "ibc_c_b" above)          ELSEIF ( ibc_s_t == 1 )  THEN             s_p(nzt+1,:,:) = s_p(nzt,:,:)          ELSEIF ( ibc_s_t == 2 )  THEN             s_p(nzt+1,:,:) = s_p(nzt,:,:) + bc_s_t_val * dzu(nzt+1)          ENDIF                 CASE ( 'set_bc_lateral' )!!-- Lateral boundary conditions for chem species at outflow boundary (following code was copied from boundary_conds. It needs to be adjusted!)          IF ( outflow_s )  THEN             IF ( passive_scalar )  s_p(:,nys-1,:) = s_p(:,nys,:)          ELSEIF ( outflow_n )  THEN             IF ( passive_scalar )  s_p(:,nyn+1,:) = s_p(:,nyn,:)          ELSEIF ( outflow_l )  THEN             IF ( passive_scalar )  s_p(:,:,nxl-1) = s_p(:,:,nxl)          ELSEIF ( outflow_r )  THEN             IF ( passive_scalar )  s_p(:,:,nxr+1) = s_p(:,:,nxr)          ENDIF! Lateral BC for inflow are automatically set when chem species are initialized (that's what Siggi told us in our discussion about BCs)! So far, I think that's all we have to do. END SUBROUTINE kchem_boundary_conds !------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_initialize      IMPLICIT   none!--   local variables      INTEGER                  :: i!--   Allocate Memory for chemical species      ALLOCATE(chem_species(NSPEC))      ALLOCATE(spec_conc_1(nzb:nzt+1,nysg:nyng,nxlg:nxrg,NSPEC))      ALLOCATE(spec_conc_2(nzb:nzt+1,nysg:nyng,nxlg:nxrg,NSPEC))      ALLOCATE(spec_conc_3(nzb:nzt+1,nysg:nyng,nxlg:nxrg,NSPEC))      if(myid == 0)  then         write(6,'(/,a,/)')  'kpp chemics >>>> List of species: '      end if      do i=1,NSPEC         chem_species(i)%name = SPC_NAMES(i)         if(myid == 0)  then            write(6,'(a,i4,3x,a)')  '   Species: ',i,trim(SPC_NAMES(i))         end if         chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg)    => spec_conc_1(:,:,:,i)         chem_species(i)%conc_p(nzb:nzt+1,nysg:nyng,nxlg:nxrg)  => spec_conc_2(:,:,:,i)         chem_species(i)%tconc_m(nzb:nzt+1,nysg:nyng,nxlg:nxrg) => spec_conc_3(:,:,:,i)         ALLOCATE (chem_species(i)%ssws(nysg:nyng,nxlg:nxrg))         ALLOCATE (chem_species(i)%sswst(nysg:nyng,nxlg:nxrg))         chem_species(i)%ssws  = 0.0_wp         chem_species(i)%sswst = 0.0_wp!          IF ( ws_scheme_sca )  THEN                                           !fk (needs to be revisited. due to            ALLOCATE (chem_species(i)%flux_s(nzb+1:nzt,0:threads_per_task-1))   !circular dependencies between check_parameters,            ALLOCATE (chem_species(i)%diss_s(nzb+1:nzt,0:threads_per_task-1))   !kchem_initialize, kchem_check_data_output,            ALLOCATE (chem_species(i)%flux_l(nzb+1:nzt,nys:nyn,0:threads_per_task-1)) !this IF clause creates problems,            ALLOCATE (chem_species(i)%diss_l(nzb+1:nzt,nys:nyn,0:threads_per_task-1)) !since ws_scheme_sca is first set "true"              chem_species(i)%flux_s = 0.0_wp                          !bK        !in check_parameters, which is so far called               chem_species(i)%flux_l = 0.0_wp                                     !after kchem_initialize            chem_species(i)%diss_s = 0.0_wp            chem_species(i)%diss_l = 0.0_wp!          ENDIF               end do!--   Set initial values      CALL set_const_initial_values      if(myid == 0)  write(6,*) ' '      RETURN     CONTAINS      SUBROUTINE set_const_initial_values         IMPLICIT   none!--      local variables         INTEGER                  :: i         if(myid == 0)  then            write(6,'(/,a,/)')  'kpp chemics >>>> Set constant Initial Values: '         end if!        Default values are taken from small_strato.def from supplied kpp example         do i=1,NSPEC            if(trim(chem_species(i)%name) == 'NO')   then!              chem_species(i)%conc = 8.725*1.0E+08               chem_species(i)%conc = 0.5_wp                           !added by bK            else if(trim(chem_species(i)%name) == 'NO2') then!              chem_species(i)%conc = 2.240*1.0E+08                            chem_species(i)%conc = 0.1_wp                           !added by bK            else if(trim(chem_species(i)%name) == 'O3') then               chem_species(i)%conc = 0.05_wp                          !added by bK            else if(trim(chem_species(i)%name) == 'H2O') then!              chem_species(i)%conc = 5.326*1.0E+11               chem_species(i)%conc = 1.30*1.0E+4_wp                   !added by bK            else if(trim(chem_species(i)%name) == 'O2') then!              chem_species(i)%conc = 1.697*1.0E+16               chem_species(i)%conc = 2.0*1.0E+5_wp                    !added by bK            else if(trim(chem_species(i)%name) == 'RH') then!               chem_species(i)%conc = 9.906*1.0E+01                chem_species(i)%conc = 2.0_wp                          !added by bK            else if(trim(chem_species(i)%name) == 'RCHO') then!              chem_species(i)%conc = 6.624*1.0E+08               chem_species(i)%conc = 2.0_wp                           !added by bK            else if(trim(chem_species(i)%name) == 'OH') then               chem_species(i)%conc = 1.0*1.0E-07_wp                   !added by bK            else if(trim(chem_species(i)%name) == 'HO2') then               chem_species(i)%conc = 1*1.0E-7_wp                      !added by bK            else if(trim(chem_species(i)%name) == 'RCCO2') then               chem_species(i)%conc = 1.0*1.0E-7_wp                    !added by bK            else if(trim(chem_species(i)%name) == 'RCOO2NO2') then               chem_species(i)%conc = 1.0*1.0E-7_wp                   !added by bK           else!   H2O = 2.0e+04;               chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg) = 0.0_wp            end if!             chem_species(i)%conc_p  = 0.0_wp            chem_species(i)%conc_p  = chem_species(i)%conc       ! added bK            chem_species(i)%tconc_m = 0.0_wp            if(myid == 0)  then               write(6,'(a,3x,a,3x,a,e12.4)')  '   Species:     ',chem_species(i)%name(1:7),' Initial Value = ',chem_species(i)%conc(nzb,nysg,nxlg)            end if         end do#if defined( __nopointer )!kk      Hier mit message abbrechen         if(myid == 0)  then            write(6,*)  '   KPP does only run with POINTER Version'         end if         stop 'error'#endif         RETURN      END SUBROUTINE set_const_initial_values   END SUBROUTINE kchem_initialize   !------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!      SUBROUTINE kchem_parin      IMPLICIT   none      CHARACTER (LEN=80)                             ::  line                   ! < dummy string that contains the current line of the parameter file      REAL(kind=wp), DIMENSION(NMAXFIXSTEPS)         ::  my_steps               ! List of fixed timesteps   my_step(1) = 0.0 automatic stepping      NAMELIST /kpp_chem/ icntrl, rcntrl, my_steps!--   Read kpp_chem namelist      icntrl    = 0      rcntrl    = 0.0_wp      my_steps  = 0.0_wp      line      = ' '      icntrl(2) = 1                                   !Atol and Rtol are Scalar      ATOL = 1.0_wp      RTOL = 0.01_wp!!--   Try to find kpp chemistry package      REWIND ( 11 )      line = ' '      DO   WHILE ( INDEX( line, '&kpp_chem' ) == 0 )        READ ( 11, '(A)', END=10 )  line      ENDDO      BACKSPACE ( 11 )!!--   Read user-defined namelist      READ ( 11, kpp_chem )      use_kpp_chemistry = .TRUE. 10   CONTINUE      t_steps = my_steps      if(myid <= 1)  then         write(6,*) 'KPP Parin ',icntrl(2),icntrl(3),ATOL(1)      end if      RETURN   END SUBROUTINE kchem_parin!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_integrate_ij (i, j)      IMPLICIT   none      INTEGER,INTENT(IN)       :: i,j!--   local variables      INTEGER                  :: k,m,istat      INTEGER,dimension(20)    :: istatus      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo! ppm to molecules/cm**3       tmp_fact = 10e-6_iwp*6.022e23_wp/22.414_wp/1000._wp     !*T/273.15*1013/p!      tmp_temp = 292!      CALL fill_temp (istat, tmp_temp)                             ! Load constant temperature into kpp context      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context      do m=1,NSPEC         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo      end do      if(myid == 0 .and. i == 10 .and. j == 10)  then         write(0,*) 'begin KPP step ',dt_3d      end if      CALL cpu_log( log_point_s(80), 'kpp_integrate', 'start' )      CALL kpp_integrate (dt_3d, tmp_conc, istatus=istatus)      CALL cpu_log( log_point_s(80), 'kpp_integrate', 'stop' )      do m=1,NSPEC         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo      end do      if(myid == 0 .and. i == 10 .and. j == 10)  then         write(6,'(a,8i7)') ' KPP Status ',istatus(1:8)      end if      RETURN   END SUBROUTINE kchem_integrate_ij!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_swap_timelevel (level)      IMPLICIT   none      INTEGER,INTENT(IN)                  :: level!--   local variables      INTEGER               :: i      if(level == 0)  then         do i=1,NSPEC            chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg)    => spec_conc_1(:,:,:,i)            chem_species(i)%conc_p(nzb:nzt+1,nysg:nyng,nxlg:nxrg)  => spec_conc_2(:,:,:,i)         end do      else         do i=1,NSPEC            chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg)    => spec_conc_2(:,:,:,i)            chem_species(i)%conc_p(nzb:nzt+1,nysg:nyng,nxlg:nxrg)  => spec_conc_1(:,:,:,i)         end do      end if      RETURN   END SUBROUTINE kchem_swap_timelevel!------------------------------------------------------------------------------!!! Description:! ------------!> Subroutine defining appropriate grid for netcdf variables.!> It is called out from subroutine netcdf.!------------------------------------------------------------------------------!   SUBROUTINE kchem_define_netcdf_grid( var, found, grid_x, grid_y, grid_z )      IMPLICIT NONE      CHARACTER (LEN=*), INTENT(IN)  ::  var         !<      LOGICAL, INTENT(OUT)           ::  found       !<      CHARACTER (LEN=*), INTENT(OUT) ::  grid_x      !<      CHARACTER (LEN=*), INTENT(OUT) ::  grid_y      !<      CHARACTER (LEN=*), INTENT(OUT) ::  grid_z      !<      found  = .TRUE.      if(var(1:3) == 'kc_')   then                    ! always the same grid for chemistry variables            grid_x = 'x'            grid_y = 'y'            grid_z = 'zu'                             !kk Use same z axis as u variables. Has to be checked if OK      else            found  = .FALSE.            grid_x = 'none'            grid_y = 'none'            grid_z = 'none'      end if      write(6,*) 'kchem_define_netcdf_grid ',TRIM(var),' ',trim(grid_x),' ',found   END SUBROUTINE kchem_define_netcdf_grid!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_check_data_output( var, unit, i, ilen, k )      USE control_parameters,                                                 &         ONLY: data_output, message_string      IMPLICIT NONE      CHARACTER (LEN=*) ::  unit     !<      CHARACTER (LEN=*) ::  var      !<      INTEGER(iwp) :: i      INTEGER(iwp) :: ilen      INTEGER(iwp) :: k      INTEGER              :: n      CHARACTER(len=16)    ::  spec_name      unit = 'illegal'      spec_name = TRIM(var(4:))      do n=1,NSPEC         if(TRIM(spec_name) == TRIM(chem_species(n)%name))   Then            unit = 'ppm'         end if      end do      RETURN   END SUBROUTINE kchem_check_data_output!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_data_output_3d( av, variable, found, local_pf )      USE indices      USE kinds      IMPLICIT NONE      CHARACTER (LEN=*) ::  variable !<      LOGICAL      ::  found !<      INTEGER(iwp) ::  av    !<      REAL(sp), DIMENSION(nxlg:nxrg,nysg:nyng,nzb:nzt+1) ::  local_pf !<      !-- local variables      INTEGER              ::  i, j, k,n      CHARACTER(len=16)    ::  spec_name      found = .FALSE.      spec_name = TRIM(variable(4:))      do n=1,NSPEC         if(TRIM(spec_name) == TRIM(chem_species(n)%name))   Then            write(6,*) 'Output of species ',TRIM(variable),' ',TRIM(chem_species(n)%name)            DO  i = nxlg, nxrg               DO  j = nysg, nyng                  DO  k = nzb, nzt+1                     local_pf(i,j,k) = chem_species(n)%conc(k,j,i)                  ENDDO               ENDDO            ENDDO            found = .TRUE.         end if      end do      RETURN   END SUBROUTINE kchem_data_output_3dEND MODULE kchem_driver
user_statistics.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
bK_passive_scalar_prognostics.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
bK_passive_scalar_prognostics.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
bK_passive_scalar_prognostics.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
kchem_driver.f90:   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn
kchem_driver.f90:        ONLY:nxl, nxr,  nxlg, nxrg, nyng, nysg, nzb_s_inner, nzt                ! bK added nzt, nzb_c_inner, nxl, nxr
kchem_driver.f90:                   rs_p(nzb_s_inner(j,i),j,i) = rs(nzb_s_inner(j,i),j,i)
kchem_driver.f90:                   rs_p(nzb_s_inner(j,i),j,i) = rs_p(nzb_s_inner(j,i)+1,j,i)
kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc           
kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp
kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo
kchem_driver.f90:      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context
kchem_driver.f90:         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo
kchem_driver.f90:         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo
subsidence_mod.f90:           ONLY:  nxl, nxlg, nxr, nxrg, nyn, nyng, nys, nysg, nzb, nzb_s_inner,&
subsidence_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt 
subsidence_mod.f90:           ONLY:  nxl, nxlg, nxrg, nyng, nys, nysg, nzb_s_inner, nzb, nzt
subsidence_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt 
microphysics_mod.f90:! nzb_2d replaced by nzb_s_inner, Kessler precipitation is stored at surface
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nxl, nxr, nyn, nys, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:                prr(nzb_s_inner(j,i),j,i) = prr(nzb_s_inner(j,i),j,i) +        &
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzt, nzb_s_inner(j,i)+1, -1
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb, nzb_s_inner, nzt
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:             w_nr(nzb_s_inner(j,i)) = w_nr(nzb_s_inner(j,i)+1)
microphysics_mod.f90:             w_qr(nzb_s_inner(j,i)) = w_qr(nzb_s_inner(j,i)+1)
microphysics_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:                DO k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:             DO  k = nzt, nzb_s_inner(j,i)+1, -1
microphysics_mod.f90:           ONLY:  nxl, nxr, nys, nyn, nzb_s_inner
microphysics_mod.f90:                                            prr(nzb_s_inner(j,i)+1,j,i) *      &
microphysics_mod.f90:                                            hyrho(nzb_s_inner(j,i)+1) * dt_3d
microphysics_mod.f90:           ONLY:  nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:          prr(nzb_s_inner(j,i),j,i) = prr(nzb_s_inner(j,i),j,i) +              &
microphysics_mod.f90:           ONLY:  nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:           ONLY:  nzb, nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzt, nzb_s_inner(j,i)+1, -1
microphysics_mod.f90:           ONLY:  nzb, nzb_s_inner, nzt
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:       w_nr(nzb_s_inner(j,i)) = w_nr(nzb_s_inner(j,i)+1)
microphysics_mod.f90:       w_qr(nzb_s_inner(j,i)) = w_qr(nzb_s_inner(j,i)+1)
microphysics_mod.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:          DO k = nzb_s_inner(j,i)+1, nzt
microphysics_mod.f90:       DO  k = nzt, nzb_s_inner(j,i)+1, -1
microphysics_mod.f90:           ONLY:  nzb_s_inner
microphysics_mod.f90:                                      prr(nzb_s_inner(j,i)+1,j,i) *            &
microphysics_mod.f90:                                      hyrho(nzb_s_inner(j,i)+1) * dt_3d
Binary file .kchem_driver.f90.swp matches
init_grid.f90:! nzb_s_inner as it is still zero at this point.
init_grid.f90:! additional 3D-flag arrays for replacing the 2D-index array nzb_s_inner in
init_grid.f90:! Initialization of nzb_s_inner and nzb_w_inner.
init_grid.f90:               nzb_diff_v, nzb_max, nzb_s_inner, nzb_s_outer, nzb_u_inner,     &
init_grid.f90:    INTEGER(iwp) ::  nzb_si        !< dummy index for local nzb_s_inner
init_grid.f90:              nzb_s_inner(nysg:nyng,nxlg:nxrg),                             &
init_grid.f90:    nzb_s_inner = nzb;  nzb_s_outer = nzb
init_grid.f90:!--       arrays nzb_u|v|w|s_inner|outer that are based on nzb_s_inner.
init_grid.f90:!--       to form the basis for nzb_s_inner. 
init_grid.f90:!--    Initialize index arrays nzb_s_inner and nzb_w_inner
init_grid.f90:       nzb_s_inner = nzb_local
init_grid.f90:!--    first pre-initialize them with nzb_s_inner...
init_grid.f90:       nzb_u_inner = nzb_s_inner
init_grid.f90:       nzb_u_outer = nzb_s_inner
init_grid.f90:       nzb_v_inner = nzb_s_inner
init_grid.f90:       nzb_v_outer = nzb_s_inner
init_grid.f90:       nzb_w_outer = nzb_s_inner
init_grid.f90:       nzb_s_outer = nzb_s_inner
init_grid.f90:!--    Since nzb_s_inner and nzb_w_inner are derived directly from nzb_local
init_grid.f90:                IF ( k <= nzb_s_inner(j,i) )  rflags_s_inner(k,j,i) = 0.0_wp
init_grid.f90:                IF ( k <= nzb_s_inner(j,i) )  rflags_invers(j,i,k)  = 0.0_wp
init_grid.f90:       nzb_diff_s_inner   = nzb_s_inner + 2
init_grid.f90:       nzb_diff_s_inner   = nzb_s_inner + 1
init_grid.f90:          IF ( nzb_s_inner(j,i) > nzb_s_inner(j+1,i) )  THEN
init_grid.f90:             wall_n(j,i) = nzb_s_inner(j+1,i) + 1            ! North wall
init_grid.f90:             IF ( nzb_s_inner(j,i) > nzb_s_inner(j,i-1) )  THEN
init_grid.f90:                corner_nl(j,i) = MAX( nzb_s_inner(j+1,i),  & ! Northleft corner
init_grid.f90:                                      nzb_s_inner(j,i-1) ) + 1
init_grid.f90:             IF ( nzb_s_inner(j,i) > nzb_s_inner(j,i+1) )  THEN
init_grid.f90:                corner_nr(j,i) = MAX( nzb_s_inner(j+1,i),  & ! Northright corner
init_grid.f90:                                      nzb_s_inner(j,i+1) ) + 1
init_grid.f90:          IF ( nzb_s_inner(j,i) > nzb_s_inner(j-1,i) )  THEN
init_grid.f90:             wall_s(j,i) = nzb_s_inner(j-1,i) + 1            ! South wall
init_grid.f90:             IF ( nzb_s_inner(j,i) > nzb_s_inner(j,i-1) )  THEN
init_grid.f90:                corner_sl(j,i) = MAX( nzb_s_inner(j-1,i),  & ! Southleft corner
init_grid.f90:                                      nzb_s_inner(j,i-1) ) + 1
init_grid.f90:             IF ( nzb_s_inner(j,i) > nzb_s_inner(j,i+1) )  THEN
init_grid.f90:                corner_sr(j,i) = MAX( nzb_s_inner(j-1,i),  & ! Southright corner
init_grid.f90:                                      nzb_s_inner(j,i+1) ) + 1
init_grid.f90:          IF ( nzb_s_inner(j,i) > nzb_s_inner(j,i-1) )  THEN
init_grid.f90:             wall_l(j,i) = nzb_s_inner(j,i-1) + 1            ! Left wall
init_grid.f90:          IF ( nzb_s_inner(j,i) > nzb_s_inner(j,i+1) )  THEN
init_grid.f90:             wall_r(j,i) = nzb_s_inner(j,i+1) + 1            ! Right wall
init_grid.f90:             nzb_si = nzb_s_inner(j,i)
20mar17_kchem_driver_MASTER.f90:   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn
20mar17_kchem_driver_MASTER.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc           
20mar17_kchem_driver_MASTER.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp
20mar17_kchem_driver_MASTER.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo
20mar17_kchem_driver_MASTER.f90:      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context
20mar17_kchem_driver_MASTER.f90:         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo
20mar17_kchem_driver_MASTER.f90:         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo
lpm_init_sgs_tke.f90:        ONLY:  nbgp, ngp_2dh_outer, nxl, nxr, nyn, nys, nzb, nzb_s_inner,      &
lpm_init_sgs_tke.f90:             IF ( k <= nzb_s_inner(j,i-1)  .AND.  k > nzb_s_inner(j,i)  .AND.  &
lpm_init_sgs_tke.f90:                  k  > nzb_s_inner(j,i+1) )                                    &
lpm_init_sgs_tke.f90:             ELSEIF ( k  > nzb_s_inner(j,i-1)  .AND.  k > nzb_s_inner(j,i)     &
lpm_init_sgs_tke.f90:                      .AND.  k <= nzb_s_inner(j,i+1) )                         &
lpm_init_sgs_tke.f90:             ELSEIF ( k < nzb_s_inner(j,i)  .AND.  k < nzb_s_inner(j,i+1) )    &
lpm_init_sgs_tke.f90:             ELSEIF ( k < nzb_s_inner(j,i-1)  .AND.  k < nzb_s_inner(j,i) )    &
lpm_init_sgs_tke.f90:             IF ( k <= nzb_s_inner(j-1,i)  .AND.  k > nzb_s_inner(j,i)  .AND.  &
lpm_init_sgs_tke.f90:                  k  > nzb_s_inner(j+1,i) )                                    &
lpm_init_sgs_tke.f90:             ELSEIF ( k  > nzb_s_inner(j-1,i)  .AND.  k  > nzb_s_inner(j,i)    &
lpm_init_sgs_tke.f90:                      .AND.  k <= nzb_s_inner(j+1,i) )                         &
lpm_init_sgs_tke.f90:             ELSEIF ( k < nzb_s_inner(j,i)  .AND.  k < nzb_s_inner(j+1,i) )    &
lpm_init_sgs_tke.f90:             ELSEIF ( k < nzb_s_inner(j-1,i)  .AND.  k < nzb_s_inner(j,i) )    &
lpm_init_sgs_tke.f90:          DO  k = nzb_s_inner(j,i)+2, nzt-1
lpm_init_sgs_tke.f90:          k = nzb_s_inner(j,i)
advec_ws.f90:           ONLY:  nbgp, nxl, nxlu, nxr, nyn, nys, nysv, nzb, nzb_s_inner,      &
advec_ws.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
advec_ws.f90:                   IF ( ( k <= nzb_s_inner(j,i+1) .OR. k <= nzb_s_inner(j,i+2) &   
advec_ws.f90:                     .OR. k <= nzb_s_inner(j,i-1) )                            &
advec_ws.f90:                   ELSEIF ( ( k <= nzb_s_inner(j,i+3) .AND. k > nzb_s_inner(j,i+1)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j,i+2)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j,i-1)&
advec_ws.f90:                            ( k <= nzb_s_inner(j,i-2) .AND. k > nzb_s_inner(j,i+1)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j,i+2)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j,i-1)&
advec_ws.f90:                   ELSEIF ( k > nzb_s_inner(j,i+1) .AND. k > nzb_s_inner(j,i+2)&
advec_ws.f90:                      .AND. k > nzb_s_inner(j,i+3) .AND. k > nzb_s_inner(j,i-1)&
advec_ws.f90:                      .AND. k > nzb_s_inner(j,i-2) )                           &
advec_ws.f90:                   IF ( ( k <= nzb_s_inner(j+1,i)  .OR. k <= nzb_s_inner(j+2,i)   &   
advec_ws.f90:                                                   .OR. k <= nzb_s_inner(j-1,i) ) &
advec_ws.f90:                   ELSEIF ( ( k <= nzb_s_inner(j+3,i) .AND. k > nzb_s_inner(j+1,i)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j+2,i)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j-1,i)&
advec_ws.f90:                            ( k <= nzb_s_inner(j-2,i) .AND. k > nzb_s_inner(j+1,i)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j+2,i)&
advec_ws.f90:                                                      .AND. k > nzb_s_inner(j-1,i)&
advec_ws.f90:                   ELSEIF ( k > nzb_s_inner(j+1,i) .AND. k > nzb_s_inner(j+2,i)&
advec_ws.f90:                      .AND. k > nzb_s_inner(j+3,i) .AND. k > nzb_s_inner(j-1,i)&
advec_ws.f90:                      .AND. k > nzb_s_inner(j-2,i) )                           &
advec_ws.f90:                   IF ( k == nzb_s_inner(j,i) + 1 .OR. k == nzt )  THEN
advec_ws.f90:                   ELSEIF ( k == nzb_s_inner(j,i) + 2 .OR. k == nzt - 1 )  THEN
advec_ws.f90:                   ELSEIF ( k > nzb_s_inner(j,i) .AND. .NOT. flag_set )  THEN
disturb_heatflux.f90:        ONLY:  nx, nxl, nxr, ny, nyn, nys, nzb, nzb_s_inner
disturb_heatflux.f90:             IF ( nzb_s_inner(j,i) == 0 )  THEN
disturb_heatflux.f90:                           * heatflux_input_conversion(nzb_s_inner(j,i))
task5_boundary_conds.f90:               nzb, nzb_s_inner, nzb_w_inner, nzt
task5_boundary_conds.f90:       !$acc kernels present( nzb_s_inner, pt, pt_p )
task5_boundary_conds.f90:             pt_p(nzb_s_inner(j,i),j,i) = pt(nzb_s_inner(j,i),j,i)
task5_boundary_conds.f90:       !$acc kernels present( nzb_s_inner, pt_p )
task5_boundary_conds.f90:             pt_p(nzb_s_inner(j,i),j,i) = pt_p(nzb_s_inner(j,i)+1,j,i)
task5_boundary_conds.f90:       !$acc kernels present( e_p, nzb_s_inner )
task5_boundary_conds.f90:             e_p(nzb_s_inner(j,i),j,i) = e_p(nzb_s_inner(j,i)+1,j,i)
task5_boundary_conds.f90:             sa_p(nzb_s_inner(j,i),j,i) = sa_p(nzb_s_inner(j,i)+1,j,i)
task5_boundary_conds.f90:                q_p(nzb_s_inner(j,i),j,i) = q(nzb_s_inner(j,i),j,i)
task5_boundary_conds.f90:                q_p(nzb_s_inner(j,i),j,i) = q_p(nzb_s_inner(j,i)+1,j,i)
task5_boundary_conds.f90:                qr_p(nzb_s_inner(j,i),j,i) = 0.0_wp
task5_boundary_conds.f90:                nr_p(nzb_s_inner(j,i),j,i) = 0.0_wp
task5_boundary_conds.f90:                s_p(nzb_s_inner(j,i),j,i) = s(nzb_s_inner(j,i),j,i)
task5_boundary_conds.f90:                s_p(nzb_s_inner(j,i),j,i) = s_p(nzb_s_inner(j,i)+1,j,i)
task1_boundary_conds.f90:               nzb, nzb_s_inner, nzb_w_inner, nzt
task1_boundary_conds.f90:       !$acc kernels present( nzb_s_inner, pt, pt_p )
task1_boundary_conds.f90:             pt_p(nzb_s_inner(j,i),j,i) = pt(nzb_s_inner(j,i),j,i)
task1_boundary_conds.f90:       !$acc kernels present( nzb_s_inner, pt_p )
task1_boundary_conds.f90:             pt_p(nzb_s_inner(j,i),j,i) = pt_p(nzb_s_inner(j,i)+1,j,i)
task1_boundary_conds.f90:       !$acc kernels present( e_p, nzb_s_inner )
task1_boundary_conds.f90:             e_p(nzb_s_inner(j,i),j,i) = e_p(nzb_s_inner(j,i)+1,j,i)
task1_boundary_conds.f90:             sa_p(nzb_s_inner(j,i),j,i) = sa_p(nzb_s_inner(j,i)+1,j,i)
task1_boundary_conds.f90:                q_p(nzb_s_inner(j,i),j,i) = q(nzb_s_inner(j,i),j,i)
task1_boundary_conds.f90:                q_p(nzb_s_inner(j,i),j,i) = q_p(nzb_s_inner(j,i)+1,j,i)
task1_boundary_conds.f90:                qr_p(nzb_s_inner(j,i),j,i) = 0.0_wp
task1_boundary_conds.f90:                nr_p(nzb_s_inner(j,i),j,i) = 0.0_wp
task1_boundary_conds.f90:                s_p(nzb_s_inner(j,i),j,i) = s(nzb_s_inner(j,i),j,i)
task1_boundary_conds.f90:                s_p(nzb_s_inner(j,i),j,i) = s_p(nzb_s_inner(j,i)+1,j,i)
production_e.f90:                   nzb_diff_s_outer, nzb_s_inner, nzt, nzt_diff
production_e.f90:                         DO  k = nzb_s_inner(j,i)+1, nzt
production_e.f90:                         DO  k = nzb_s_inner(j,i)+1, nzt
production_e.f90:                  nzb_diff_s_inner, nzb_diff_s_outer, nzb_s_inner, nzt,        &
production_e.f90:       !$acc         present( nzb_s_inner, pt, q, ql, qsws, qswst, rho_ocean )                &
production_e.f90:                            IF ( k > nzb_s_inner(j,i) )  THEN
production_e.f90:                            IF ( k > nzb_s_inner(j,i) )  THEN
production_e.f90:                  nzb_diff_s_outer, nzb_s_inner, nzt, nzt_diff
production_e.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
production_e.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
diffusivities.f90:        ONLY:  nxl, nxlg, nxr, nxrg, nyn, nyng, nys, nysg, nzb_s_inner, nzb, nzt
diffusivities.f90:    !$acc data present( dd2zu, e, km, kh, l_grid, l_wall, nzb_s_inner, var )
diffusivities.f90:                IF ( k > nzb_s_inner(j,i) )  THEN
diffusivities.f90:             IF ( k > nzb_s_inner(j,i) )  THEN
diffusivities.f90:          km(nzb_s_inner(j,i),j,i) = km(nzb_s_inner(j,i)+1,j,i)
diffusivities.f90:          kh(nzb_s_inner(j,i),j,i) = kh(nzb_s_inner(j,i)+1,j,i)
abc:newfile.f90:!> @file kchem_driver.f90!------------------------------------------------------------------------------!! This file is part of PALM.!! PALM is free software: you can redistribute it and/or modify it under the! terms of the GNU General Public License as published by the Free Software! Foundation, either version 3 of the License, or (at your option) any later! version.!! PALM is distributed in the hope that it will be useful, but WITHOUT ANY! WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR! A PARTICULAR PURPOSE.  See the GNU General Public License for more details.!! You should have received a copy of the GNU General Public License along with! PALM. If not, see <http://www.gnu.org/licenses/>.!! Copyright 1997-2016 Leibniz Universitaet Hannover!------------------------------------------------------------------------------!!! Current revisions:! -----------------! kk: Intial version (Klaus Ketelsen)! bK: Changed initial values of chem_species! RFo: Added tmp_fact! FKa: Some formatting, todos added below, "_wp" added to REAL quantities' values,!      the "if(var(1:3) == 'kc_')" is now included in check_parameters (as done!      for "usm_" quantities!! Former revisions:! -----------------!! Description:! ------------!> Interface PALM <-> kpp chemistry!>!> @todo Format this module according to PALM coding standard (see e.g. module!>       template under http://palm.muk.uni-hannover.de/mosaik/downloads/8 or!>       D3_coding_standard.pdf under https://palm.muk.uni-hannover.de/trac/downloads/16)!> @todo Rename ssws, sswst to csws, cswst to avoid confusion with ssws/sswst !>       used together with passive scalar s!> @todo Use same run index for all loops over NSPEC, e.g. nsp = 1, NSPEC!>       (and: NSPEC-->nspec, i.e. no capital letters in variable names !>       [see formatting rules])!> @todo "#ifdef KPP_CHEM" --> "#if defined( __chem)" (see other examples !>       in PALM)               #if defined( __parallel )!> @todo „write(6...“ printing should eventually be handled in a separate !>       subroutine „kchem_header“ (see e.g. how it is done in routine !>       lsm_header in land_surface_model_mod.f90), which prints this !>       information to a MONITORING file named <jobname>_header (in this file, !>       all PALM setup information are included)!> @todo Not all routines have meaningful names yet, e.g. "kchem_integrate" only!>       refers to chemical reactions part, but the name itself could also refer!>       to the other part of the chemistry integration (advection/diffusion)!>       --> Please clarify!> @todo Rename flag „use_kpp_chemistry“ to „chemistry“ (see e.g. flag !>       „plant_canopy“ used for the plant canopy model!> @todo Please enter all of your TODOs here in this list!> @todo Every subroutine needs a "Description" header !>       (as e.g. in urban_surface_mod.f90)!> @todo Clear circular dependencies between check_parameters, kchem_initialize,!>       and kchem_check_data_output!------------------------------------------------------------------------------!ODULE kchem_driver   USE kinds,              ONLY: wp, iwp   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn   USE pegrid,             ONLY: myid, threads_per_task   USE control_parameters, ONLY: dt_3d, ws_scheme_sca  !ws_sch... added by bK   USE arrays_3d,          ONLY: pt   USE kchem_kpp,          ONLY: NSPEC, SPC_NAMES, NKPPCTRL, NMAXFIXSTEPS, t_steps, FILL_TEMP, kpp_integrate,     &                                 ATOL,RTOL   USE cpulog,             ONLY: cpu_log, log_point_s   IMPLICIT   none   PRIVATE   SAVE!- Define chemical variables   TYPE   species_def      CHARACTER(LEN=8)                                   :: name      CHARACTER(LEN=16)                                  :: unit      REAL(kind=wp),POINTER,DIMENSION(:,:,:)             :: conc      REAL(kind=wp),POINTER,DIMENSION(:,:,:)             :: conc_p      REAL(kind=wp),POINTER,DIMENSION(:,:,:)             :: tconc_m      REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:)           :: ssws, sswst      REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:)           :: flux_s, diss_s      REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:,:)         :: flux_l, diss_l   END TYPE species_def   PUBLIC  species_def   logical, PUBLIC                                               :: use_kpp_chemistry = .FALSE.   TYPE(species_def),ALLOCATABLE,DIMENSION(:),TARGET, PUBLIC     :: chem_species   REAL(kind=wp),ALLOCATABLE,DIMENSION(:,:,:,:),TARGET   :: spec_conc_1,spec_conc_2,spec_conc_3   INTEGER,DIMENSION(NKPPCTRL)                           :: icntrl                            ! Fine tuning kpp   REAL(kind=wp),DIMENSION(NKPPCTRL)                     :: rcntrl                            ! Fine tuning kpp   PUBLIC NSPEC!- Interface section   INTERFACE kchem_boundary_conds      MODULE PROCEDURE kchem_boundary_conds   END INTERFACE kchem_boundary_conds   INTERFACE kchem_initialize      MODULE PROCEDURE kchem_initialize   END INTERFACE kchem_initialize   INTERFACE kchem_parin      MODULE PROCEDURE kchem_parin   END INTERFACE kchem_parin   INTERFACE kchem_integrate      MODULE PROCEDURE kchem_integrate_ij   END INTERFACE kchem_integrate   INTERFACE kchem_swap_timelevel      MODULE PROCEDURE kchem_swap_timelevel   END INTERFACE kchem_swap_timelevel   INTERFACE kchem_define_netcdf_grid      MODULE PROCEDURE kchem_define_netcdf_grid   END INTERFACE kchem_define_netcdf_grid   INTERFACE kchem_data_output_3d      MODULE PROCEDURE kchem_data_output_3d   END INTERFACE kchem_data_output_3d   INTERFACE kchem_check_data_output      MODULE PROCEDURE kchem_check_data_output   END INTERFACE kchem_check_data_output   PUBLIC kchem_boundary_conds, kchem_check_data_output, kchem_data_output_3d, &          kchem_define_netcdf_grid, kchem_initialize, kchem_integrate,         &          kchem_parin, kchem_swap_timelevel             CONTAINS !------------------------------------------------------------------------------!! Description:! ------------!> Initialize and set all boundary conditions for chemical species concentration!------------------------------------------------------------------------------! SUBROUTINE kchem_boundary_conds( mode )                                        !Please note alphabetical order of listings, and also all other formatting                                                                                !and continue in that exact way.    USE control_parameters,                                                    & !you might also have to add some other quantities here, since        ONLY: outflow_l, outflow_n, outflow_r, outflow_s            USE indices,                                                               & !I didn't check for all that might be necessary to add to ONLY list        ONLY: nxlg, nxrg, nyng, nysg      IMPLICIT NONE        CHARACTER (len=*), INTENT(IN) :: mode    SELECT CASE ( TRIM( mode ) )       CASE ( 'init' )!         This part below is from check_parameters.f90's SUBROUTINE set_bc_scalars!         I already adjusted this part to work for chem species (see notes under CASE('set_bc_bottomtop'))!!--       Set Integer flags and check for possible erroneous settings for !--       bottom boundary condition  (the integer flags are then used in CASE('set_bc_bottomtop'))          IF ( bc_c_b == 'dirichlet' )  THEN             ibc_c_b = 0          ELSEIF ( bc_c_b == 'neumann' )  THEN             ibc_c_b = 1          ELSE             message_string = 'unknown boundary condition: bc_c_b ="' // TRIM( bc_c_b ) // '"'             CALL message( 'kchem_boundary_conds', 'CHEM001', 1, 2, 0, 6, 0 )     !checks in kchem_driver have special error numbers --> "CHEM###",          ENDIF                                                                   !so that we don't mix them up with PALM error numbers "PA0###"!!--       Set Integer flags and check for possible erroneous settings for top!--       boundary condition          IF ( bc_c_t == 'dirichlet' )  THEN             ibc_c_t = 0          ELSEIF ( bc_c_t == 'neumann' )  THEN             ibc_c_t = 1          ELSEIF ( bc_c_t == 'initial_gradient' )  THEN             ibc_c_t = 2          ELSEIF ( bc_c_t == 'nested' )  THEN             ibc_c_t = 3          ELSE             message_string = 'unknown boundary condition: bc_c_t ="' // TRIM( bc_c_t ) // '"'             CALL message( 'check_parameters', 'CHEM002', 1, 2, 0, 6, 0 )          ENDIF!!--       We might later on need some parameter checkings as in check_parameters.f90's SUBROUTINE check_bc_scalars!--       (these should be put under a new SUBROUTINE kchem_check_parameters, see e.g. urban_surface_mod.f90 also has SUBROUTINE usm_check_parameters)               CASE ( 'set_bc_bottomtop' ) !!--       Surface conditions for chemical species     !!!!this is the code for passive_scalar (copied from boundary_conds.f90)                                                       !!!!---> modify this to work for chemical species!!!          IF ( ibc_s_b == 0 ) THEN                    !use "ibc_c_b" for chem species. you have to declare it in kchem_driver's global decleration part.                                                      !and make it PUBLICly available. same holds for ibc_c_t, bc_c_b/bc_c_t.                                                      !don't confuse the integer flag "ibc_c_b" with the &kpp_chem parameter "bc_c_b" which needs to                                                      !be defined as a parameter in kchem_parin. "bc_c_b" can take the same values as "bc_s_b" (see PALM                                                      !documentation)             DO  i = nxlg, nxrg                                       DO  j = nysg, nyng                                               s_p(nzb_s_inner(j,i),j,i) = s(nzb_s_inner(j,i),j,i)                ENDDO             ENDDO          ELSE             DO  i = nxlg, nxrg                DO  j = nysg, nyng                   s_p(nzb_s_inner(j,i),j,i) = s_p(nzb_s_inner(j,i)+1,j,i)                ENDDO             ENDDO          ENDIF!!--       Top boundary conditions for chemical species          IF ( ibc_s_t == 0 )  THEN                    !use "ibc_c_t" for chem species. you have to declare it in kchem_driver global decleration part             s_p(nzt+1,:,:) = s(nzt+1,:,:)             !(see notes for "ibc_c_b" above)          ELSEIF ( ibc_s_t == 1 )  THEN             s_p(nzt+1,:,:) = s_p(nzt,:,:)          ELSEIF ( ibc_s_t == 2 )  THEN             s_p(nzt+1,:,:) = s_p(nzt,:,:) + bc_s_t_val * dzu(nzt+1)          ENDIF                 CASE ( 'set_bc_lateral' )!!-- Lateral boundary conditions for chem species at outflow boundary (following code was copied from boundary_conds. It needs to be adjusted!)          IF ( outflow_s )  THEN             IF ( passive_scalar )  s_p(:,nys-1,:) = s_p(:,nys,:)          ELSEIF ( outflow_n )  THEN             IF ( passive_scalar )  s_p(:,nyn+1,:) = s_p(:,nyn,:)          ELSEIF ( outflow_l )  THEN             IF ( passive_scalar )  s_p(:,:,nxl-1) = s_p(:,:,nxl)          ELSEIF ( outflow_r )  THEN             IF ( passive_scalar )  s_p(:,:,nxr+1) = s_p(:,:,nxr)          ENDIF! Lateral BC for inflow are automatically set when chem species are initialized (that's what Siggi told us in our discussion about BCs)! So far, I think that's all we have to do. END SUBROUTINE kchem_boundary_conds !------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_initialize      IMPLICIT   none!--   local variables      INTEGER                  :: i!--   Allocate Memory for chemical species      ALLOCATE(chem_species(NSPEC))      ALLOCATE(spec_conc_1(nzb:nzt+1,nysg:nyng,nxlg:nxrg,NSPEC))      ALLOCATE(spec_conc_2(nzb:nzt+1,nysg:nyng,nxlg:nxrg,NSPEC))      ALLOCATE(spec_conc_3(nzb:nzt+1,nysg:nyng,nxlg:nxrg,NSPEC))      if(myid == 0)  then         write(6,'(/,a,/)')  'kpp chemics >>>> List of species: '      end if      do i=1,NSPEC         chem_species(i)%name = SPC_NAMES(i)         if(myid == 0)  then            write(6,'(a,i4,3x,a)')  '   Species: ',i,trim(SPC_NAMES(i))         end if         chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg)    => spec_conc_1(:,:,:,i)         chem_species(i)%conc_p(nzb:nzt+1,nysg:nyng,nxlg:nxrg)  => spec_conc_2(:,:,:,i)         chem_species(i)%tconc_m(nzb:nzt+1,nysg:nyng,nxlg:nxrg) => spec_conc_3(:,:,:,i)         ALLOCATE (chem_species(i)%ssws(nysg:nyng,nxlg:nxrg))         ALLOCATE (chem_species(i)%sswst(nysg:nyng,nxlg:nxrg))         chem_species(i)%ssws  = 0.0_wp         chem_species(i)%sswst = 0.0_wp!          IF ( ws_scheme_sca )  THEN                                           !fk (needs to be revisited. due to            ALLOCATE (chem_species(i)%flux_s(nzb+1:nzt,0:threads_per_task-1))   !circular dependencies between check_parameters,            ALLOCATE (chem_species(i)%diss_s(nzb+1:nzt,0:threads_per_task-1))   !kchem_initialize, kchem_check_data_output,            ALLOCATE (chem_species(i)%flux_l(nzb+1:nzt,nys:nyn,0:threads_per_task-1)) !this IF clause creates problems,            ALLOCATE (chem_species(i)%diss_l(nzb+1:nzt,nys:nyn,0:threads_per_task-1)) !since ws_scheme_sca is first set "true"              chem_species(i)%flux_s = 0.0_wp                          !bK        !in check_parameters, which is so far called               chem_species(i)%flux_l = 0.0_wp                                     !after kchem_initialize            chem_species(i)%diss_s = 0.0_wp            chem_species(i)%diss_l = 0.0_wp!          ENDIF               end do!--   Set initial values      CALL set_const_initial_values      if(myid == 0)  write(6,*) ' '      RETURN     CONTAINS      SUBROUTINE set_const_initial_values         IMPLICIT   none!--      local variables         INTEGER                  :: i         if(myid == 0)  then            write(6,'(/,a,/)')  'kpp chemics >>>> Set constant Initial Values: '         end if!        Default values are taken from small_strato.def from supplied kpp example         do i=1,NSPEC            if(trim(chem_species(i)%name) == 'NO')   then!              chem_species(i)%conc = 8.725*1.0E+08               chem_species(i)%conc = 0.5_wp                           !added by bK            else if(trim(chem_species(i)%name) == 'NO2') then!              chem_species(i)%conc = 2.240*1.0E+08                            chem_species(i)%conc = 0.1_wp                           !added by bK            else if(trim(chem_species(i)%name) == 'O3') then               chem_species(i)%conc = 0.05_wp                          !added by bK            else if(trim(chem_species(i)%name) == 'H2O') then!              chem_species(i)%conc = 5.326*1.0E+11               chem_species(i)%conc = 1.30*1.0E+4_wp                   !added by bK            else if(trim(chem_species(i)%name) == 'O2') then!              chem_species(i)%conc = 1.697*1.0E+16               chem_species(i)%conc = 2.0*1.0E+5_wp                    !added by bK            else if(trim(chem_species(i)%name) == 'RH') then!               chem_species(i)%conc = 9.906*1.0E+01                chem_species(i)%conc = 2.0_wp                          !added by bK            else if(trim(chem_species(i)%name) == 'RCHO') then!              chem_species(i)%conc = 6.624*1.0E+08               chem_species(i)%conc = 2.0_wp                           !added by bK            else if(trim(chem_species(i)%name) == 'OH') then               chem_species(i)%conc = 1.0*1.0E-07_wp                   !added by bK            else if(trim(chem_species(i)%name) == 'HO2') then               chem_species(i)%conc = 1*1.0E-7_wp                      !added by bK            else if(trim(chem_species(i)%name) == 'RCCO2') then               chem_species(i)%conc = 1.0*1.0E-7_wp                    !added by bK            else if(trim(chem_species(i)%name) == 'RCOO2NO2') then               chem_species(i)%conc = 1.0*1.0E-7_wp                   !added by bK           else!   H2O = 2.0e+04;               chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg) = 0.0_wp            end if!             chem_species(i)%conc_p  = 0.0_wp            chem_species(i)%conc_p  = chem_species(i)%conc       ! added bK            chem_species(i)%tconc_m = 0.0_wp            if(myid == 0)  then               write(6,'(a,3x,a,3x,a,e12.4)')  '   Species:     ',chem_species(i)%name(1:7),' Initial Value = ',chem_species(i)%conc(nzb,nysg,nxlg)            end if         end do#if defined( __nopointer )!kk      Hier mit message abbrechen         if(myid == 0)  then            write(6,*)  '   KPP does only run with POINTER Version'         end if         stop 'error'#endif         RETURN      END SUBROUTINE set_const_initial_values   END SUBROUTINE kchem_initialize   !------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!      SUBROUTINE kchem_parin      IMPLICIT   none      CHARACTER (LEN=80)                             ::  line                   ! < dummy string that contains the current line of the parameter file      REAL(kind=wp), DIMENSION(NMAXFIXSTEPS)         ::  my_steps               ! List of fixed timesteps   my_step(1) = 0.0 automatic stepping      NAMELIST /kpp_chem/ icntrl, rcntrl, my_steps!--   Read kpp_chem namelist      icntrl    = 0      rcntrl    = 0.0_wp      my_steps  = 0.0_wp      line      = ' '      icntrl(2) = 1                                   !Atol and Rtol are Scalar      ATOL = 1.0_wp      RTOL = 0.01_wp!!--   Try to find kpp chemistry package      REWIND ( 11 )      line = ' '      DO   WHILE ( INDEX( line, '&kpp_chem' ) == 0 )        READ ( 11, '(A)', END=10 )  line      ENDDO      BACKSPACE ( 11 )!!--   Read user-defined namelist      READ ( 11, kpp_chem )      use_kpp_chemistry = .TRUE. 10   CONTINUE      t_steps = my_steps      if(myid <= 1)  then         write(6,*) 'KPP Parin ',icntrl(2),icntrl(3),ATOL(1)      end if      RETURN   END SUBROUTINE kchem_parin!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_integrate_ij (i, j)      IMPLICIT   none      INTEGER,INTENT(IN)       :: i,j!--   local variables      INTEGER                  :: k,m,istat      INTEGER,dimension(20)    :: istatus      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo! ppm to molecules/cm**3       tmp_fact = 10e-6_iwp*6.022e23_wp/22.414_wp/1000._wp     !*T/273.15*1013/p!      tmp_temp = 292!      CALL fill_temp (istat, tmp_temp)                             ! Load constant temperature into kpp context      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context      do m=1,NSPEC         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo      end do      if(myid == 0 .and. i == 10 .and. j == 10)  then         write(0,*) 'begin KPP step ',dt_3d      end if      CALL cpu_log( log_point_s(80), 'kpp_integrate', 'start' )      CALL kpp_integrate (dt_3d, tmp_conc, istatus=istatus)      CALL cpu_log( log_point_s(80), 'kpp_integrate', 'stop' )      do m=1,NSPEC         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo      end do      if(myid == 0 .and. i == 10 .and. j == 10)  then         write(6,'(a,8i7)') ' KPP Status ',istatus(1:8)      end if      RETURN   END SUBROUTINE kchem_integrate_ij!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_swap_timelevel (level)      IMPLICIT   none      INTEGER,INTENT(IN)                  :: level!--   local variables      INTEGER               :: i      if(level == 0)  then         do i=1,NSPEC            chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg)    => spec_conc_1(:,:,:,i)            chem_species(i)%conc_p(nzb:nzt+1,nysg:nyng,nxlg:nxrg)  => spec_conc_2(:,:,:,i)         end do      else         do i=1,NSPEC            chem_species(i)%conc(nzb:nzt+1,nysg:nyng,nxlg:nxrg)    => spec_conc_2(:,:,:,i)            chem_species(i)%conc_p(nzb:nzt+1,nysg:nyng,nxlg:nxrg)  => spec_conc_1(:,:,:,i)         end do      end if      RETURN   END SUBROUTINE kchem_swap_timelevel!------------------------------------------------------------------------------!!! Description:! ------------!> Subroutine defining appropriate grid for netcdf variables.!> It is called out from subroutine netcdf.!------------------------------------------------------------------------------!   SUBROUTINE kchem_define_netcdf_grid( var, found, grid_x, grid_y, grid_z )      IMPLICIT NONE      CHARACTER (LEN=*), INTENT(IN)  ::  var         !<      LOGICAL, INTENT(OUT)           ::  found       !<      CHARACTER (LEN=*), INTENT(OUT) ::  grid_x      !<      CHARACTER (LEN=*), INTENT(OUT) ::  grid_y      !<      CHARACTER (LEN=*), INTENT(OUT) ::  grid_z      !<      found  = .TRUE.      if(var(1:3) == 'kc_')   then                    ! always the same grid for chemistry variables            grid_x = 'x'            grid_y = 'y'            grid_z = 'zu'                             !kk Use same z axis as u variables. Has to be checked if OK      else            found  = .FALSE.            grid_x = 'none'            grid_y = 'none'            grid_z = 'none'      end if      write(6,*) 'kchem_define_netcdf_grid ',TRIM(var),' ',trim(grid_x),' ',found   END SUBROUTINE kchem_define_netcdf_grid!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_check_data_output( var, unit, i, ilen, k )      USE control_parameters,                                                 &         ONLY: data_output, message_string      IMPLICIT NONE      CHARACTER (LEN=*) ::  unit     !<      CHARACTER (LEN=*) ::  var      !<      INTEGER(iwp) :: i      INTEGER(iwp) :: ilen      INTEGER(iwp) :: k      INTEGER              :: n      CHARACTER(len=16)    ::  spec_name      unit = 'illegal'      spec_name = TRIM(var(4:))      do n=1,NSPEC         if(TRIM(spec_name) == TRIM(chem_species(n)%name))   Then            unit = 'ppm'         end if      end do      RETURN   END SUBROUTINE kchem_check_data_output!------------------------------------------------------------------------------!! Description:! ------------!> is missing!------------------------------------------------------------------------------!   SUBROUTINE kchem_data_output_3d( av, variable, found, local_pf )      USE indices      USE kinds      IMPLICIT NONE      CHARACTER (LEN=*) ::  variable !<      LOGICAL      ::  found !<      INTEGER(iwp) ::  av    !<      REAL(sp), DIMENSION(nxlg:nxrg,nysg:nyng,nzb:nzt+1) ::  local_pf !<      !-- local variables      INTEGER              ::  i, j, k,n      CHARACTER(len=16)    ::  spec_name      found = .FALSE.      spec_name = TRIM(variable(4:))      do n=1,NSPEC         if(TRIM(spec_name) == TRIM(chem_species(n)%name))   Then            write(6,*) 'Output of species ',TRIM(variable),' ',TRIM(chem_species(n)%name)            DO  i = nxlg, nxrg               DO  j = nysg, nyng                  DO  k = nzb, nzt+1                     local_pf(i,j,k) = chem_species(n)%conc(k,j,i)                  ENDDO               ENDDO            ENDDO            found = .TRUE.         end if      end do      RETURN   END SUBROUTINE kchem_data_output_3dEND MODULE kchem_driver
abc:init_dvrp.f90:                         local_pf(i,j,nzb:nzb_s_inner(j,i)) = 1.0_wp
init_dvrp.f90:        ONLY:  nx, nxl, nxr, ny, nyn, nys, nzb, nzb_s_inner
init_dvrp.f90:                      IF ( nzb_s_inner(j,i) > 0 )  THEN
init_dvrp.f90:                         local_pf(i,j,nzb:nzb_s_inner(j,i)) = 1.0_wp
land_surface_model_mod.f90:        ONLY:  nbgp, nxlg, nxrg, nyng, nysg, nzb, nzb_s_inner 
land_surface_model_mod.f90:          k = nzb_s_inner(j,i)
land_surface_model_mod.f90:                k = nzb_s_inner(j,i)
land_surface_model_mod.f90:                k = nzb_s_inner(j,i)                
land_surface_model_mod.f90:             k = nzb_s_inner(j,i)
modules.f90:                   nzb_diff_v, nzb_inner, nzb_outer, nzb_s_inner, nzb_s_outer,    &
prognostic_equations.f90:               nysv, nzb_s_inner, nzb_u_inner, nzb_v_inner, nzb_w_inner, nzb, nzt, &
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:!               IF (myid == 2 ) print*, ' *** val of nzb_s_inner, nzt :', nzb_s_inner(j,i), nzt 
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                      DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:       !$acc kernels present( nzb_s_inner, rdf_sc, ptdf_x, ptdf_y, pt_init ) &
prognostic_equations.f90:                IF ( k > nzb_s_inner(j,i) )  THEN
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:       !$acc kernels present( e, e_p, nzb_s_inner, tend, te_m )
prognostic_equations.f90:                IF ( k > nzb_s_inner(j,i) )  THEN
prognostic_equations.f90:    DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:          DO  k = nzb_s_inner(j,i)+1, nzt
prognostic_equations.f90:          DO  k = nzb_s_inner(j,i)+1, nzt
advec_s_up.f90:           ONLY:  nxl, nxlg, nxr, nxrg, nyn, nyng, nys, nysg, nzb, nzb_s_inner,&
advec_s_up.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
advec_s_up.f90:           ONLY:  nxlg, nxrg, nyng, nysg, nzb, nzb_s_inner, nzt
advec_s_up.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
boundary_conds.f90:               nzb, nzb_s_inner, nzb_w_inner, nzt
boundary_conds.f90:       !$acc kernels present( nzb_s_inner, pt, pt_p )
boundary_conds.f90:             pt_p(nzb_s_inner(j,i),j,i) = pt(nzb_s_inner(j,i),j,i)
boundary_conds.f90:       !$acc kernels present( nzb_s_inner, pt_p )
boundary_conds.f90:!                IF (myid == 2) print*, ' pe_id is',myid,'  and  the val is BEFORE', nzb_s_inner(j,i)                ! bK
boundary_conds.f90:                 pt_p(nzb_s_inner(j,i),j,i) = pt_p(nzb_s_inner(j,i)+1,j,i)                                              
boundary_conds.f90:!                IF (myid == 2) print*, ' pe_id is',myid,'  and pt_p val is AFTER',  pt_p(nzb_s_inner(j,i),j,i)     ! bK
boundary_conds.f90:       !$acc kernels present( e_p, nzb_s_inner )
boundary_conds.f90:             e_p(nzb_s_inner(j,i),j,i) = e_p(nzb_s_inner(j,i)+1,j,i)
boundary_conds.f90:             sa_p(nzb_s_inner(j,i),j,i) = sa_p(nzb_s_inner(j,i)+1,j,i)
boundary_conds.f90:                q_p(nzb_s_inner(j,i),j,i) = q(nzb_s_inner(j,i),j,i)
boundary_conds.f90:                q_p(nzb_s_inner(j,i),j,i) = q_p(nzb_s_inner(j,i)+1,j,i)
boundary_conds.f90:                qr_p(nzb_s_inner(j,i),j,i) = 0.0_wp
boundary_conds.f90:                nr_p(nzb_s_inner(j,i),j,i) = 0.0_wp
boundary_conds.f90:                s_p(nzb_s_inner(j,i),j,i) = s(nzb_s_inner(j,i),j,i)
boundary_conds.f90:                    IF (myid == 0) print*, ' *** val of s_p array is ***** ', s_p(nzb_s_inner(j,i),j,i)
boundary_conds.f90:                s_p(nzb_s_inner(j,i),j,i) = s_p(nzb_s_inner(j,i)+1,j,i)
lpm_advec.f90:        ONLY:  nzb, nzb_s_inner, nzt
lpm_advec.f90:               zv(n) - zw(nzb_s_inner(jlog,ilog)) < z_p )  THEN
lpm_advec.f90:             IF ( zv(n) - zw(nzb_s_inner(jlog,ilog)) < z0_av_global )  THEN
lpm_advec.f90:                height_p = ( zv(n) - zw(nzb_s_inner(jlog,ilog)) - z0_av_global ) &
lpm_advec.f90:               zv(n) - zw(nzb_s_inner(jlog,ilog)) < z_p )  THEN
lpm_advec.f90:             IF ( zv(n) - zw(nzb_s_inner(jlog,ilog)) < z0_av_global )  THEN
lpm_advec.f90:                height_p = ( zv(n) - zw(nzb_s_inner(jlog,ilog)) - z0_av_global ) &
lpm_advec.f90:             IF ( k > nzb_s_inner(j,i)  .OR.  nzb_s_inner(j,i) == 0 )  THEN 
lpm_advec.f90:             IF ( k > nzb_s_inner(j+1,i)  .OR.  nzb_s_inner(j+1,i) == 0 )  THEN
lpm_advec.f90:             IF ( k+1 > nzb_s_inner(j,i)  .OR.  nzb_s_inner(j,i) == 0 )  THEN
lpm_advec.f90:             IF ( k+1 > nzb_s_inner(j+1,i)  .OR.  nzb_s_inner(j+1,i) == 0 )  THEN
lpm_advec.f90:             IF ( k > nzb_s_inner(j,i+1)  .OR.  nzb_s_inner(j,i+1) == 0 )  THEN
lpm_advec.f90:             IF ( k > nzb_s_inner(j+1,i+1)  .OR.  nzb_s_inner(j+1,i+1) == 0 )  THEN
lpm_advec.f90:             IF ( k+1 > nzb_s_inner(j,i+1)  .OR.  nzb_s_inner(j,i+1) == 0 )  THEN
lpm_advec.f90:             IF ( k+1 > nzb_s_inner(j+1,i+1)  .OR.  nzb_s_inner(j+1,i+1) == 0)  THEN
flow_statistics.f90:!> @note For simplicity, nzb_s_inner and nzb_diff_s_inner are being used as a
flow_statistics.f90:                nzb_s_inner, nzt, nzt_diff
flow_statistics.f90:             DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:                DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:                DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:                   DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:                DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:!--    NOTE: for simplicity, nzb_s_inner is used below, although strictly 
flow_statistics.f90:             DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:                DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:             DO  k = nzb_s_inner(j,i), nzt+1
flow_statistics.f90:!--          NOTE: for simplicity, nzb_s_inner is used below, although strictly 
flow_statistics.f90:             DO  k = nzb_s_inner(j,i), nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt+1
flow_statistics.f90:               nzb_s_inner, nzt, nzt_diff, rflags_invers
flow_statistics.f90:!--    NOTE: for simplicity, nzb_s_inner is used below, although strictly
flow_statistics.f90:!--    NOTE: for simplicity, nzb_s_inner is used below, although
flow_statistics.f90:!--    NOTE: for simplicity, nzb_s_inner is used below, although strictly
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt
flow_statistics.f90:                DO  k = nzb_s_inner(j,i)+1, nzt+1
diffusion_s.f90:                  nzb_diff_s_inner, nzb_s_inner, nzb_s_outer, nzt, nzt_diff
diffusion_s.f90:                DO  k = nzb_s_inner(j,i)+1, nzb_s_outer(j,i)
diffusion_s.f90:                k = nzb_s_inner(j,i)+1
diffusion_s.f90:                 nzb, nzb_diff_s_inner, nzb_s_inner, nzb_s_outer, nzt, nzt_diff
diffusion_s.f90:       !$acc         present( nzb_diff_s_inner, nzb_s_inner, nzb_s_outer, s ) &
diffusion_s.f90:                IF ( k > nzb_s_inner(j,i)  .AND.  k <= nzb_s_outer(j,i)  .AND. &
diffusion_s.f90:                IF ( use_surface_fluxes  .AND.  k == nzb_s_inner(j,i)+1 )  THEN
diffusion_s.f90:           ONLY:  nxlg, nxrg, nyng, nysg, nzb, nzb_diff_s_inner, nzb_s_inner,  &
diffusion_s.f90:          DO  k = nzb_s_inner(j,i)+1, nzb_s_outer(j,i)
diffusion_s.f90:          k = nzb_s_inner(j,i)+1
netcdf_interface_mod.f90:!--          Define zusi = zu(nzb_s_inner)
netcdf_interface_mod.f90:                                     'meters', 'zu(nzb_s_inner)', 488, 489,    &
netcdf_interface_mod.f90:!--          Define zusi = zu(nzb_s_inner)
netcdf_interface_mod.f90:                                     'zu(nzb_s_inner)', 413, 414, 415 )
netcdf_interface_mod.f90:!--          Define zusi = zu(nzb_s_inner)
netcdf_interface_mod.f90:                                     'zu(nzb_s_inner)', 421, 422, 423 )
lpm_boundary_conds.f90:        ONLY:  nxl, nxr, nyn, nys, nz, nzb_s_inner
lpm_boundary_conds.f90:          zwall1 = zw(nzb_s_inner(j2,i2))
lpm_boundary_conds.f90:          zwall2 = zw(nzb_s_inner(j1,i1))
lpm_boundary_conds.f90:          zwall3 = zw(nzb_s_inner(j1,i2))
lpm_boundary_conds.f90:          zwall4 = zw(nzb_s_inner(j2,i1))
lpm_boundary_conds.f90:                     pos_z <= zw(nzb_s_inner(j3,i3)) .AND.                     &
lpm_boundary_conds.f90:                     pos_z <= zw(nzb_s_inner(j3,i3)) .AND.                     &
lpm_boundary_conds.f90:                   IF ( pos_z - zw(nzb_s_inner(j3,i3)) < eps ) THEN
lpm_boundary_conds.f90:                      pos_z = MAX( 2.0_wp * zw(nzb_s_inner(j3,i3)) - pos_z,    &
lpm_boundary_conds.f90:                                   zw(nzb_s_inner(j3,i3)) )
task5_driver_MASTER.f90:   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn
task5_driver_MASTER.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc           
task5_driver_MASTER.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp
task5_driver_MASTER.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo
task5_driver_MASTER.f90:      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context
task5_driver_MASTER.f90:         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo
task5_driver_MASTER.f90:         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo
buoyancy.f90:                  nzb_s_inner, nzt
buoyancy.f90:                DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:                  nxrg, nyn, nyng, nys, nysg, nzb, nzb_s_inner, nzt
buoyancy.f90:          !$acc kernels present( nzb_s_inner, ref_state, tend, var )
buoyancy.f90:                DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:                   DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:           ONLY:  nxlg, nxrg, nyng, nysg, nzb, nzb_s_inner, nzt
buoyancy.f90:          DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:             DO  k = nzb_s_inner(j,i)+1, nzt-1
buoyancy.f90:             DO  k = nzb_s_inner(j,i)+1, nzt-1
radiation_model_mod.f90:        ONLY:  nxl, nxlg, nxr, nxrg, nyn, nyng, nys, nysg, nzb_s_inner, nzb, nzt
radiation_model_mod.f90:             k = nzb_s_inner(j,i)
radiation_model_mod.f90:             k = nzb_s_inner(j,i)
interaction_droplets_ptq.f90:! nzb_2d replaced by nzb_s_inner
interaction_droplets_ptq.f90:           ONLY:  nxl, nxr, nyn, nys, nzb_s_inner, nzt
interaction_droplets_ptq.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
interaction_droplets_ptq.f90:           ONLY:  nzb_s_inner, nzt
interaction_droplets_ptq.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
calc_liquid_water_content.f90:        ONLY:  nxlg, nxrg, nyng, nysg, nzb_s_inner, nzt
calc_liquid_water_content.f90:          DO  k = nzb_s_inner(j,i)+1, nzt
21mar17_kchem_driver.f90:   USE indices,            ONLY: nzb,nzt,nysg,nyng,nxlg,nxrg,nzb_s_inner,nys,nyn
21mar17_kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt,NSPEC)                :: tmp_conc           
21mar17_kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_temp
21mar17_kchem_driver.f90:      REAL(kind=wp),dimension(nzb_s_inner(j,i)+1:nzt)                      :: tmp_fact   !! RFo
21mar17_kchem_driver.f90:      CALL fill_temp (istat, pt(nzb_s_inner(j,i)+1:nzt,j,i))                             ! Load temperature into kpp context
21mar17_kchem_driver.f90:         tmp_conc(:,m) = chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) * tmp_fact(:) ! RFo
21mar17_kchem_driver.f90:         chem_species(m)%conc (nzb_s_inner(j,i)+1:nzt,j,i) = tmp_conc(:,m) / tmp_fact(:)  ! RFo
calc_mean_profile.f90:           ONLY:  ngp_2dh_s_inner, nxl, nxr, nyn, nys, nzb, nzb_s_inner, nzt
calc_mean_profile.f90:                DO  k = nzb_s_inner(j,i), nzt+1
plant_canopy_model_mod.f90:               nz, nzb, nzb_s_inner, nzb_u_inner, nzb_v_inner, nzb_w_inner, nzt
plant_canopy_model_mod.f90:                kk = nzb_s_inner(j, i)
plant_canopy_model_mod.f90:                   DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                      kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:                   DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                      kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:                   DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                      kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:                   DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                      kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
plant_canopy_model_mod.f90:             DO  k = nzb_s_inner(j,i)+1, nzb_s_inner(j,i)+pch_index
plant_canopy_model_mod.f90:                kk = k - nzb_s_inner(j,i)  !- lad arrays are defined flat
eqn_state_seawater.f90:           ONLY:  nxl, nxr, nyn, nys, nzb_s_inner, nzt
eqn_state_seawater.f90:             DO  k = nzb_s_inner(j,i)+1, nzt
eqn_state_seawater.f90:             prho(nzb_s_inner(j,i),j,i) = prho(nzb_s_inner(j,i)+1,j,i)
eqn_state_seawater.f90:             rho_ocean(nzb_s_inner(j,i),j,i)  = rho_ocean(nzb_s_inner(j,i)+1,j,i)
eqn_state_seawater.f90:           ONLY:  nzb_s_inner, nzt
eqn_state_seawater.f90:       DO  k = nzb_s_inner(j,i)+1, nzt
eqn_state_seawater.f90:       prho(nzb_s_inner(j,i),j,i) = prho(nzb_s_inner(j,i)+1,j,i)
eqn_state_seawater.f90:       rho_ocean(nzb_s_inner(j,i),j,i)  = rho_ocean(nzb_s_inner(j,i)+1,j,i)
init_3d_model.f90:                         IF ( nzb_s_inner(j,i) /= 0 )  THEN
init_3d_model.f90:                                  * heatflux_input_conversion(nzb_s_inner(j,i))
init_3d_model.f90:                         IF ( nzb_s_inner(j,i) /= 0 )  THEN
init_3d_model.f90:                                 * waterflux_input_conversion(nzb_s_inner(j,i))
init_3d_model.f90:                         IF ( nzb_s_inner(j,i) /= 0 )  ssws(j,i) = wall_sflux(0)
init_3d_model.f90:                         IF ( nzb_s_inner(j,i) /= 0 ) rssws(j,i) = wall_sflux(0)
init_3d_model.f90:       !$acc data copyin( d, ddzu, ddzw, nzb_s_inner, nzb_u_inner )            &
init_3d_model.f90:                                                  + zw(nzb_s_inner(j,i))
init_3d_model.f90:                DO  k = nzb_s_inner(j,i), nz + 1
init_3d_model.f90:                                     + ( nz - nzb_s_inner(j,i) + 2 )
